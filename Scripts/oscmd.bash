#!/bin/bash
# This script is used by all other ProgrammingRenaissance (PR) scripts and provides
# support for running commands via Bash.
# It has the ability to capture the output of the command being run, from stdout
# and stderr.
# This cpture can either be permanent, allowing post-mortem examination of the
# command output, or it can be temporary where the output format of the messages
# is modified to make the output more readable. This means simple things such as
# indenting messages from the command so that they visually look associated with
# output from this script.
# It is also possible to discard command messags and this is done by default for
# commands that do not fail. Messages from commands that failed are always
# displayed. It is possible to ensure that all command output is visible.
# Permanent retention of output is done by redirecting command output to files,
# while message formatting is done during command execution.

# Where commands are long-running it is possible to specify that they run
# asynchronously wth the rest of the script and a method for the user to be 
# signalled when the command terminates is provided.


# Variables that are static and only need to be initialized once.
# The following variables are actually Ansi escpe sequences that set or clear the
# specified attribute on text that is displayed on a terminal. Not all terminals
# support all sequences, but they generally silently discard the sequences that
# they do not support.

declare -r ERED='\e[1;31m' # Emphasised red
declare -r NC='\e[0m' # No color

# Names of the args associative array keys
declare -lr ucommand='ucommand'
declare -lr umsg='umsg'
declare -lr stderr_redirection='stderr_redirection'
declare -lr stdout_redirection='stdout_redirection'

cmd () {
  # Runs an operating system command. It normally captures stderr so that the
  # OS generated messages can be formatted for better readibility. It allows
  # both stdout and stderr to be captured to files where the contents can be
  # examined. If the filea are located in the /tmp directory, they will be purged
  # when the command completes. The user can provide functions to handle these
  # files as arguments to this function.

  # Arguments

  #    Positional

  #    Optional 

  # Returns

  # Error Detection

  # Define our variables
  declare -l stderr_source='/dev/stdin'
  declare -l stdin_source=''
  declare -l stderr_function=''
  declare -l stdout_function='' 
  declare -l command="$1 2->&1"
  declare -A args=([$ucommand]='' [$umsg]=''\
                   [$stderr_redirection]='2>&1' [$stdout_redirection]='')


  # Get the function arguments - the optional ones arrive as an associative array.
  # The command prototype is the only required argument and it is always the first
  # argument to be supplied.
  if (($# < 1 || $# > 2)); # Check that we have a valid bumber of arguments
  then
    if [[ $("declare -p $1") == *"--"* ]]; #  look at P1 and see if it is a string
    then # We have a string which should be our first positioal argument
         # Assume that it must be a raw command to be executed
      args[ucommand]="$1" # Gets the raw command from the user
      shift 1
      # We can fall through and test if we got an associative array of optional
      # arguments
    fi
    # Make sure that we got an associative array
    if [[ $("declare -p $1") == *"-A"* ]];
    then # Loop saving the arguments in the associative array
      for key in ${!1[@]}:
      do # Set a new value for an optional keyword, overriding the default value
        [[ "${args[key]+abc}" ]] && (args[key] = $1[key]; continue;)
        echo "oscmd: Unrecognized argument: $key=${1[$key]}"
        exit 1
      done
    else
      echo "oscmd: we got an unexpected argument: $1"
      exit 1
    fi
  else
    echo "oscmd: cmd incorrect number of arguments - $?. Should be 1 or 2"
    exit 1
  fi

  while $# >= 0;
  do
    case $# in
    # We support a maximum of 4 arguments. They are all keyword arguments and
    # are stored in the args associative array.
    4) # A skeleton of a string that defines the command to be run. It normally
       # leaves redirection of sydout and stderr to this command and uses the
       # redirection capabilities of this function to allow the user to capture
       # the stdout and stderr output generated by the command being run.
       ;;
    3) # A message to be logged on the screen, explaining something useful about the
       # command, to be used if an error occurs. This message is provided by the
       # application that is using this function
      ;;
    2) # Where to get redirected stderr input using read. Defaults to /dev/stdin but
       # can be a file.
      ;;
    1) # Where to get redirected stdout input using read, Defaults to empty file
       # name. If both stderr and stdout streams need to be captured, stderr is
       # via stdin and stdout is via a temporary file. If only stdout needs to be
       # captured, it can be via stdin. Both stdout and stderr can be redirected to
       # files for later examination or stderr can be redireted to stdout to merge
       # the two output streams.
      ;;
    esac
    shift 1 # Get the next argument
  done

  # Variables that cannot be set until the funcion arguments have been captured.
  
  msgs=$(command) # Run the command and get the error messages from stderr
  if (( $? != 0 ));
    ret=$? # Get the return code from the command
    echo -e "${bold}${RED}Error:${NC}${normal} $1 failed with return code ${bold}${RED}$ret${NC}${normal}";

     exit 1; }
  return 0
}